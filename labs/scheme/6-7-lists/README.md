# Упражнение 5 – Списъци

### Задaча 1
Да се напишат функциите `(take n lst)` и `(drop n lst)`, който съответно взимат или премахват първите n елемента на списък:

```scheme
(take 3 '(1 2 3 4 5)) -> '(1 2 3)
(take 10 '(1 2 3 4 5)) -> '(1 2 3 4 5)
(drop 3 '(1 2 3 4 5)) -> '(4 5)
(drop 10 '(1 2 3 4 5)) -> '()
```

### Задача 2
Да се напишат функциите `(all? p? lst)` и `(any? p? lst)`, които проверяват съответно дали всички или някои елементи на даден списък изпълняват предиката `p?`:

```scheme
(all? even? '(1 2 3 4 5)) -> #f
(any? even? '(1 2 3 4 5)) -> #t
(any? (lambda (x) (> x 10)) '(4 2 6 3 1)) -> #f
```

### Задача 3
Да се напише функция `(zip lst1 lst2)`, която приема два списъка и връща списък от наредени двойки от техните съответни елементи:

```scheme
(zip '(1 2 3 4) '(#t #f #f)) -> '((1 . #t) (2 . #f) (3 . #f))
```

### Задача 4
Да се напише функция `(zipWith f lst1 lst2)`, която връща списъка, получен от прилагането на f върху съответните елементи на двата списъка lst1 и lst2.

```scheme
(zipWith + '(1 2 3 4) '(7 10 12)) -> '(8 12 15)
```

Каква е връзката между `zip` и `zipWith`?

### Задача 5
Да се напише функция `(sorted? lst)`, която проверява дали списък е сортиран в ненамаляващ ред.

### Задача 6.
Да се напише функция `(uniques lst)`, която оставя само уникалните стойности в даден списък. Можете да проверявате за еднаквост с `equal?` за най-сигурно.

```scheme
(uniques '(1 2 2 "iei" 1 3 "iei" 'oops)) -> '(1 2 "iei" 3 'oops) ; подредбата в резултата няма значение
```

### Задача 7.
Да се напише функция `(insert val lst)`, която вмъква стойността `val` на правилното място в сортирания в ненамаляващ ред списък `lst`:

```scheme
(insert 5 '(1 4 10)) -> '(1 4 5 10)
(insert 12 '(1 4 10)) -> '(1 4 10 12))
```

### Задача 8.
Да се напише функция `(insertion-sort lst)`, която прави точно това, което подсказва името ѝ:

```scheme
(insertion-sort '(4 3 6 2 1 8 10)) -> '(1 2 3 4 6 8 10)
```

### Задача 9.
Отворен числов интервал `(a;b)` се описва с наредената двойка `(a . b)`. Да се напише функция `longest-interval-subsets`, която по даден списък от интервали `il` връща нов списък, който съдържа всички интервали от `il`, които са подинтервали на най-дългия интервал в списъка.
Бонус: Функцията `longest-interval-subsets` да връща подинтервалите подредени в нарастващ ред по началната си точка.

```scheme
(longest-interval-subsets
  '((24 . 25) (90 . 110) (0 . 100) (10 . 109) (1 . 3) (-4 . 2)))
-> ((0 . 100) (1 . 3) (24 . 25))
```

### Задача 10.
Да се напише функция `(compose . fns)`, която приема произволен брой функции като аргументи и връща тяхната композиция:

```scheme
(define (sq x) (* x x))
(define (1+ x) (+ x 1))
(define f (compose sq 1+ (lambda (x) (* x 2)) 1+))
; това е екв. на: (sq
                     (1+
                        ((lambda (x) (* x 2))
                                             (1+ 5))))
(f 5) -> 169
```

### Задача 11*.
Да се напише функция `(group-by f lst)`, която групира елементите на списъка `lst` по стойността, която `f` връща за тях:

```scheme
(group-by even? '(1 2 3 4 5)) -> ((#f (1 3 5))
                                  (#t (2 4))) ; подредбата няма значение
(group-by length '((1 2 3) (4) (5 6 7))) -> '((1 ((4)))
                                              (3 ((1 2 3) (5 6 7))))
```

### Задача 12**.
Да се напише функция `(zipWith* f . lsts)`,  която работи аналогично на `zipWith`, но с произволен брой списъци като аргументи:

```scheme
(zipWith* list '(1 2 3) '(a b) '(7 8 9 10)) -> '((1 a 7) (2 b 8))
(zipWith* + '(1 2 3)) -> '(1 2 3) ; все пак броят списъци е произволен
(zipWith* void) -> '() ; why does this make my head hurt
```

Упътване: можете да подавате аргументи на такъв тип функции с `apply`:

```scheme
(apply + 2 3 5) <=> (+ 2 3 5) -> 10
```

### Задача 13.
Да се реализира функция `splitsquares`, която в дълбок списък от числа заменя всички числа `x`, които могат да се представят като x = y<sup>2</sup> + z<sup>2</sup> за някои положителни цели числа `y`, `z`, със списъка `(y z)`.

```scheme
(splitsquares '((1 (2)) (((3) 4) (5 (6)) () (7)) 8))) --> ((1 ((1 1))) (((3) 4) ((1 4) (6)) () (7)) (4 4)))
```
Упътване: използвайте `deep-foldr`

### Задача 14.
С помощта на `deep-foldr` да се реализира функцията `fake-foldr`, която прави дясно (недълбоко) свиване над списък от атоми.

### Задача 15.
Да се реализира дълбоко ляво свиване `deep-foldl`: а) директно, б) чрез `map` и `foldl`.

### Задача 16.
С помощта на `deep-foldl` да се реализира по-ефективен вариант на `deep-reverse`.
